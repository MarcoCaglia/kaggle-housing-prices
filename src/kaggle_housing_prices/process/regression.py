"""Regression module for housing price prediction."""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any, Dict, Tuple, Union

import numpy as np
import numpy.typing as npt
import pandas as pd
from sklearn.base import BaseEstimator
from sklearn.ensemble import (
    AdaBoostRegressor,
    GradientBoostingRegressor,
    RandomForestRegressor,
    VotingRegressor,
)
from sklearn.linear_model import LassoCV, Ridge
from sklearn.metrics import mean_squared_error, mean_squared_log_error, r2_score
from sklearn.svm import SVR


class BaseRegressor(ABC):
    """Template class for classification classes."""

    def __init__(self, **kwargs) -> None:
        """Initialize regressor class."""
        for attr, value in kwargs.items():
            setattr(self, attr, value)

    @abstractmethod
    def fit(
        self, X: pd.DataFrame, y: npt.NDArray[np.float32], **kwargs
    ) -> BaseRegressor:
        """Fit regression model to observed features and labels.

        Args:
            X (pd.DataFrame): Features generated by feature engineering.
            y (npt.NDArray[np.float32]): Observed labels in training data.

        Returns:
            BaseRegressor: Fit instance of self.
        """

    @abstractmethod
    def predict(self, X: pd.DataFrame, **kwargs) -> npt.NDArray[np.float32]:
        """Predict labels from engineered input features.

        Args:
            X (pd.DataFrame): Engineered input features.

        Returns:
            npt.NDArray[np.float32]: Predicted values.
        """

    @abstractmethod
    def get_report(
        self,
        y_hat: npt.NDArray[np.float32],
        y: Union[npt.NDArray[np.float32], None] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        """Get regression report.

        If observed prices are included, the regression report will include
        additional label-dependent metrics.

        Args:
            y_hat (npt.NDArray[np.float32]): Predicted values.
            y (npt.NDArray[np.float32], None], optional): Observed prices. If
                specified, additional, label-dependent metrics are returned.
                Defaults to None.

        Returns:
            Dict[str, Any]: Dictionary of EDA artifacts.
        """


class SklearnRegressor(BaseRegressor):
    """Regression using sklearn implementations."""

    def __init__(
        self, regression_method: BaseEstimator = GradientBoostingRegressor(), **kwargs
    ) -> None:
        """Initialize SklearnRegressor with regression_method.

        Keyword arguments are passed to the regression method if they are
        applicable to the chosen method.

        Args:
            regression_method (BaseEstimator, optional): Sklearn class to use
                for regression. Defaults to GradientBoostingRegressor().
        """
        self.method = regression_method.set_params(
            **{
                key: value
                for key, value in kwargs.items()
                if key in list(regression_method.get_params().keys())
            }
        )

    def fit(  # noqa
        self, X: pd.DataFrame, y: npt.NDArray[np.float32], **kwargs
    ) -> BaseRegressor:
        self.method.fit(X, y)

        return self

    def predict(self, X: pd.DataFrame, **kwargs) -> npt.NDArray[np.float32]:  # noqa
        y_hat = self.method.predict(X)

        # The prediction can never be negative
        y_hat[np.where(y_hat < 0)] = 0

        return y_hat

    def get_report(
        self,
        y_hat: npt.NDArray[np.float32],
        y: Union[npt.NDArray[np.float32], None] = None,
        **kwargs,
    ) -> Dict[str, Any]:
        # Get reports
        independent_report = self._get_independent_report(y_hat)
        if y is not None:
            dependent_report = self._get_dependent_report(y_hat, y)
        else:
            dependent_report = {}

        # Compile full report
        report = {**independent_report, **dependent_report}

        return report

    def _get_independent_report(self, y_hat: npt.NDArray[np.float32]) -> Dict[str, Any]:
        # Get report solely based on prediction.
        report = {}

        # Get basic statistics of prediction
        report["predicted_mean"] = np.mean(y_hat)
        report["predicted_std"] = np.std(y_hat)

        return report

    def _get_dependent_report(
        self, y_hat: npt.NDArray[np.float32], y: npt.NDArray[np.float32]
    ) -> Dict[str, Any]:
        # Get report based on combination of observed and predicted labels
        report = {}

        # Get observed basic statistics
        report["observed_mean"] = np.mean(y)
        report["observed_std"] = np.std(y)

        # Get residuals
        report["residuals"] = y - y_hat

        # Get Quality metrics
        report["r2"] = r2_score(y, y_hat)
        report["mse"] = mean_squared_error(y, y_hat)
        report["msle"] = mean_squared_log_error(y, y_hat)
        report["root_msle"] = report.get("msle") ** (1 / 2)

        return report


class DefaultEstimators:
    """Holds default estimators for MetaRegressor."""

    default_estimators = (
        ("grad_boost", GradientBoostingRegressor()),
        ("ada_boost", AdaBoostRegressor()),
        ("rad_for", RandomForestRegressor()),
        ("ridge", Ridge()),
        ("svr", SVR()),
    )


class MetaRegressor(VotingRegressor, SklearnRegressor):
    """Implements meta regression by combining regression results."""

    def __init__(
        self,
        estimators=DefaultEstimators.default_estimators,
    ):
        super().__init__(estimators)
        self.meta_regressor = LassoCV(selection="random")

    def fit(
        self, X: pd.DataFrame, y: npt.NDArray[np.float32], **kwargs
    ) -> BaseRegressor:
        # Fit all estimators
        for _, model in self.estimators:
            model.fit(X, y)

        # Get meta training data
        meta_features = self._get_meta_features(X)

        # Train Meta Regressor

        self.meta_regressor.fit(meta_features, y)

        return self

    def predict(self, X: pd.DataFrame, **kwargs) -> npt.NDArray[np.float32]:
        # Generate meta features
        meta_features = self._get_meta_features(X)

        # Make prediction
        prediction = self.meta_regressor.predict(meta_features).astype(np.float32)

        return prediction

    def _get_meta_features(self, X: Union[pd.DataFrame, npt.NDArray]):
        # Returns features, with additional regression encodings
        meta_features = np.hstack(
            [self._get_array(X)]
            + [model.predict(X).reshape(-1, 1) for _, model in self.estimators]
        )

        return meta_features

    @staticmethod
    def _get_array(X: Union[pd.DataFrame, npt.NDArray]) -> npt.NDArray:
        # Gets the matrix of X if X is a dataframe, otherwise, returns X
        if isinstance(X, pd.DataFrame):
            return X.to_numpy()
        elif isinstance(X, np.ndarray):
            return X
        else:
            raise AssertionError(
                f"X is neither pandas DF nor numpy array; got {type(X)}"
            )
